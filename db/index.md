### 索结结构（方法）

 **Hash索引** ：对于每一行数据，存储引擎都会对所有的索引列的值计算一个哈希码存储在哈希表中。哈希索引只包含哈希值和行指针（指向实际的行数据），当有哈希冲突时，则会逐行比较符合查询条件的数据行。

 -  **优点** ：如果是等值查询，则效率非常高，时间复杂度为O(1)，例如：查询某个列等于某个值的时候，只需要计算这个列的hash码，就能快速定位到这行数据，效率当然很高。
 -  **缺点**：Hash索引的缺点也很明细，只支持等值比较查询如：=，in(),<=>(严格比较两个NULL值是否相等,两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0)，不支持任何范围查询，因为它是计算索引列的哈希码存储的，范围查找就失去了意义，而且无法用于排序，同时它也不支持部分索引列匹配查找，比如多个索引列，只匹配其中的部分列是做不到的，因为它是将所有的索引列计算出一个哈希码。哈希索引只包含哈希值和行指针，所以不能使用覆盖索引。

总的来说，Hash索引只适合特定的场景，它的限制极多。

**BTree索引**：mysql中称为B+树索引（查看表的索引时，显示的索引类型是BTree，实际实现的是B+树），在介绍B+树之前先介绍一下B树（B树、BTree、B-Tree都是同一个概念，都称为BTree），B树是一种多路自平衡搜索树，它类似普通的二叉树，但是B树允许每个节点有更多的子节点（二叉树一个节点下最多两个节点，而B树下一个节点可以有超过两个的节点），特点是：

- 所有节点中即包含记录的索引key值和这条记录的所有数据，以及指向下一个节点的指针；
- 任何一条记录出现且只出现在一个节点中；
- 搜索可能在非叶子节点时就结束了（因为节点中包含这条记录的所有数据，查到某条记录可以直接返回）；

以下为BTree的结构图：
![输入图片说明](image.png)

B+树是对B树的升级，非叶子节点只存储索引列和下一个节点的指针（不再存储数据了），叶子节点存储索引列和数据，以现实中的树木比喻说明就是，BTree更加繁茂，而B+树相对精简，以下为B+树的结构图：

![输入图片说明](../image.png)

那么为什么不用BTree而是用的B+树呢？见下面的问题。

参考：[一文看懂B TREE和B+TREE数据结构实现过程及数据存储结构](https://blog.csdn.net/qq_28721869/article/details/115803481)


### 为什么采用 B+树

### 聚集索引、普通索引、覆盖索引，最左前缀匹配原则

### 什么情况下索引会失效
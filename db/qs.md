### 并发事务带来的问题
并发事务会带来哪些问题？

-  **脏读：** 一个事务读取另外一个事务尚未提交的数据。因为未提交，所以可能随时撤回或者修改，导致了根据这个数据进行的一些操作可能是不正确的。这种情况被称为脏读。

-  **幻读：** 在同一个事务里多次查询结果集不一致，多了或者少了等。比如第一次查询得到一个list，另外一个事务在进行新增或者删除，导致，进行第二次查询时得到的list比第一次多或者少等，这种情况被称为幻读。

-  **不可重复读：** 在同一个事务中，同一条记录，多次查询结果不一致。比如一条记录第一次查询时某个值，但同时另一个事务在修改这条记录，导致进行第二次查询这条记录时与上一次的值不一致。

-  **丢失修改：** 一个事务中读取了某个记录，并修改了记录，但是尚未提交，另外一个事务此时也读取到了同样的记录，同样的值，做了另外的修改，前一个事务先提交后一个事务再提交，但是前一个事务修改的值被后一个事务覆盖了，导致它做的修改丢失。比如，事务1读取count=20，让它减2，但是还没有把结果提交，这个时候另一个事务2也读取了count=20，让他减1，当事务1和2先后提交后，count=19，导致事务1做的修改并没有生效。

### 事务隔离级别
为了解决多个事务并发会引发的问题。数据库系统提供了四种事务隔离级别供用户选择。

-  **读未提交（Read uncommitted）** ：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据（基本不会设置这种隔离级别）
-  **读已提交（Read committed）** ：只能读取到已经提交的数据。Oracle，postgresql等多数数据库默认都是该级别
-  **可重复读（Repeatable read）** ：可重复读，在同一个事务内的查询都是事务开始时刻一致的，不管查询多少次都是同一条记录。（mysql默认隔离级别）
-  **串行读(Serializable)** ：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

| 隔离级别  | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read）  |  幻读（Phantom Read） |
|----------------------------------------------------------------|---|---|---|
|  读未提交（Read uncommitted） |  可能 |  可能 | 可能  |
|  读已提交（Read committed） |  不可能 | 可能  |  可能 |
|  可重复读（Repeatable read） |  不可能 | 不可能  |  可能 |
|  可串行化（Serializable ） | 不可能  |  不可能 | 不可能  |


### mysql如何实现可重复读的？


# 垃圾收集算法

GC算法网上已经有一大堆了，相信很多人已经看了至少2~3遍，在这里简单的过一遍。

### 1. GC算法有哪些？各有什么优缺点？

#### 1.1 标记-清除 算法

算法分为两个阶段，先标记，后清除。先将需要回收的对象进行标记，然后统一清除。

算法简单，缺点是会产生内存碎片。


#### 1.2 复制算法

将内存分为两块，每次使用其中的一块，当内存不足时，将存活的对象复制到另一块内存中去，剩下的直接清除。

回收后内存时连续的，缺点是会浪费一些内存，因为每次只使用其中的一块。

#### 1.3 标记-整理 算法

类似标记清除算法，只是在回收的时候将存活的对象移动到一端，剩下的清除掉。

充分使用了内存，也避免了内存碎片。因为要移动对象，效率较低。


#### 1.4 分代算法
严格上讲，它并不是一个算法，只是按照对象存活的特性将内存分成不同的区域，在不同的区域采用不同的算法，而这些算法是上面三种的组合。

JVM中，堆内存被分为新生代和老年代。

新生代中，又细划分为，Eden、Survivor1、Survivor2，这个区域一般是复制算法

老年代，对象在新生代中经过多次复制后仍然存活（默认是对象年龄达到15），会被复制到老年代，或者大对象等直接在老年代分配，而老年代根据垃圾收集器的不同，会采用不同的算法，如标记清除，标记整理等


| 算法名称 | 优点 | 缺点 |
|------|----|----|
| 标记清除 |  实现简单  |  回收后内存会变得不连续，即内存碎片，新创建的大对象可能会不够分配  |
| 复制算法 |  GC后的内存空间是连续的  | 一部分的内存浪费 |
| 标记整理 |  GC后内存是连续的，也没有浪费内存  | 效率低 |
| 分代算法 |  将内存划分成不同的区域，采用不同的收集算法进行回收| -  |


### 2. 如何判断对象已死亡？（如何标记哪些对象需要被回收）

回收算法就是为了回收不再存活的对象，那么如何判断对象死亡呢？

#### 2.1 引用计数法
每个对象中都有一个计数器，每当对象被引用一次就加1，失去引用就减1，这样当计数器为0时，代表着可回收。这种方法足够简单高效，但是解决不了循环引用问题，例如：

```
    public class A {
        public B b;
    }

    public class B {
        public A a;
    }

   public static void main(String[] args) {
        
        A a = new A();
        B b = new B();
        a.b = b;
        b.a = a;
        a = null;
        b = null;
    }
``` 
a 对象中引用b对象，b对象中引用a对象，导致a、b的计数器都不为0，本该被回收的对象无法回收，该方法基本不被虚拟机使用。

#### 2.2 可达性分析

通过一些列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时（就是从GC Roots 到这个对象是不可达），则证明此对象是不可用的，它们会被判定为可回收对象，当然要真正宣告一个对象死亡，至少要经历两次标记过程。

可以作为GC Roots中的对象：

1.JAVA虚拟机栈中引用的对象（线程私有的空间，说明线程正在执行中，栈帧中引用的对象多少都是存活的）

2.本地方法栈(Native方法)中引用的对象（与虚拟机栈类似）

3.方法区中类静态变量和常量引用的对象


### 3. 垃圾收集器CMS和G1 的介绍

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的


参考:

[弄明白CMS和G1，就靠这一篇了](https://juejin.cn/post/6844903974676463629)

[面试官问我G1回收器怎么知道你是什么时候的垃圾？](https://www.cnblogs.com/thisiswhy/p/12388638.html)


